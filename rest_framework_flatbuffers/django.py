import importlib

import flatbuffers


class FBSerializerMixin(object):
    """
    A mixin that provides flatbuffer serialization support

    Can also generate the fbs for your with self.generate_fbs
    Requires self.fb_fields containing the fields you wish to serialize
    and self.fb_model (str) containing an importable path to the flatbuffer
    compiled serialazer class generated by flatc

    Assumes a Django Rest Framework style Meta class with `fields` and `model`
    attributes
    """
    @property
    def model_name(self):
        return self.Meta.model.__module__

    @property
    def django_model(self):
        i = importlib.import_module(self.Meta.model.__module__)
        dm = getattr(i, self.Meta.model.__name__)

        return dm

    @property
    def fb_fields(self):
        fields = []
        for field in list(self.django_model._meta.fields):
            if type(field) in FBS_MAP and field.name in self.Meta.fields:
                fields.append(field)

        return fields

    def generate_fbs(self):
        fbs = 'namespace {}fb;\n\n'.format(self.Meta.model.__module__)
        fbs += 'table {}'.format(self.Meta.model.__name__) + 'FB {\n'
        for field in self.fb_fields:
            if type(field) in FBS_MAP:
                fbs += '  {}:{};\n'.format(field.name, FBS_MAP[type(field)])

        fbs += '}\n\n'
        fbs += 'root_type {};'.format(self.Meta.model.__name__ + 'FB')

        return fbs

    def fb_serialize(self):
        """
        Perform django model to flatbuffer serialaztion on all fields in
        self.fb_fields
        """
        FB = importlib.import_module('{}.{}'.format(
            self.Meta.model.__module__ + 'fb',
            self.Meta.model.__name__ + 'FB'))

        _meta = self.django_model._meta

        fields = [
            field for field in _meta.get_all_field_names()
            if field in [f.name for f in self.fb_fields]
        ]

        builder = flatbuffers.Builder(1024)

        nonscalars = {}

        # Create non-scalars before doing Start
        for field in fields:
            value = getattr(self.instance, field)
            f = _meta.get_field(field)
            t = TYPE_MAP[f.get_internal_type()]
            AddField = self.Meta.model.__name__ + 'FBAdd' + to_camel(field)

            if t in (str, unicode):
                if value:
                    nonscalars[AddField] = builder.CreateString(str(value))
                else:
                    nonscalars[AddField] = builder.CreateString('')

        # Do the serialization
        start = getattr(FB, self.Meta.model.__name__ + 'FBStart')
        end = getattr(FB, self.Meta.model.__name__ + 'FBEnd')
        start(builder)

        for field in fields:
            value = getattr(self.instance, field)
            f = _meta.get_field(field)
            t = TYPE_MAP[f.get_internal_type()]
            AddField = self.Meta.model.__name__ + 'FBAdd' + to_camel(field)

            if AddField not in nonscalars.keys():
                if not value:
                    value = NULL_MAP[f.get_internal_type()]
                getattr(FB, AddField)(builder, value)
            else:
                getattr(FB, AddField)(builder, nonscalars[AddField])

        buf = end(builder)

        builder.Finish(buf)

        return builder.Output()


def to_camel(s):
    """
    Snake case to camel case helper
    """
    components = s.split('_')
    return "".join(c.title() for c in components)
